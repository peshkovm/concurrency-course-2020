## Взаимная блокировка

В этой задаче вам нужно воспроизвести самый известный многопоточный баг – *взаимную блокировку* или *дэдлок* (*deadlock*).

Назовем *взаимной блокировкой* потоков ситуацию, в которой ни один из них не может продолжить исполнение, добиться прогресса, независимо от дальнейшего планирования потоков. 

Дэдлок – терминальная конфигурация системы, выйти из него нельзя. В этом его отличие от другого многопоточного бага – *лайвлока* (*livelock*), из которого всегда можно выйти при удачном планировании потоков.

---

Воспроизводить многопоточные баги сложно:
- Невозможно точно предсказать, когда планировщик операционной системы захочет снять текущий поток с процессора
- *Вытеснение* (*preemption*) происходит прозрачно для кода потока, он даже не узнает о том, что бы прерван

Чтобы преодолеть эти сложности, мы будем пользоваться специальными *кооперативными* потоками – *файберами*, с собственным планировщиком, который запускается и планирует файберы внутри одного потока операционной системы.

Главная особенность файберов – они отдают управление планировщику только явно:
- При вызове `Yield()` или `SleepFor(duration)`
- При вызове `mutex.Lock()` на захваченном мьютексе

Семантика вызова `Yield()` – уступить исполнение следующему в очереди на исполнение файберу. 

Планировщик не может вытеснить запущенный файбер по собственной воле. 

Используя файберы, мы можем выстраивать детерминированные конкурентные исполнения, контролируя точки переключения файберов с помощью вызовов `Yield()`, `mutex.Lock()` и `mutex.Unlock()`.

При этом суть взаимной блокировки от замены потоков на файберы не меняется.

---

Ваша задача – завести файберы в дэдлок. 

Для этого заполните лямбды с комментарием
```cpp
// Your code goes here
```

Планировщик автоматически обнаружит дэдлок и бросит исключение `DeadlockDetected`.
