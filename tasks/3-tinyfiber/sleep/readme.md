# SleepFor

Вам даны однопоточные файберы с примитивной реализацией функции `SleepFor`:

```cpp
void Scheduler::SleepFor(Duration delay) {
  Timer timer;
  do {
    Yield();
  } while (timer.Elapsed() < delay);
}
````

Как видно, файбер в вызове `SleepFor` вовсе не спит, а постоянно перепланируется, отвлекая планировщик от полезной работы.

Вы должны реализовать `SleepFor` эффективнее: спящий файбер не должен постоянно получать управление и перепланироваться, планировщик не должен тратить на него процессорное время.

Если в планировщике нет файберов, которые готовы исполняться, но при этом есть спящие файберы, то планировщик должен блокировать свой _поток_ до пробуждения первого файбера.

Обратите внимание, что никакая реализация `SleepFor` не может гарантировать, что файбер возобновит исполнение точно через заказанное время, просто в силу кооперативной природы файберов. Файбер обязан проспать не меньше `delay`, но чем точнее будет задержка, тем лучше.

---

Если посмотреть на файберы как на маленькую модель операционной системы, то от вас требуется реализовать системный вызов `sleep`.

## Декомпозиция

В решении вы должны стремиться к минимальному изменению класса `Scheduler`. Метод `RunLoop` должен оставаться коротким и легко читаемым.

Логика по управлению очередью спящих файберов и связанные структуры данных должны быть инкапсулированы в отдельном классе. Тщательно продумайте интерфейс такой очереди. Рекомендуем начать с изменения цикла планировщика: _сначала_ подобрать удобный интерфейс, и только _потом_ писать реализацию.

Идеи вы можете почерпнуть из решения задачи [Sleep-Asio](/tasks/3-tinyfiber/sleep-asio).

## Файлы решения

Вы можете изменять содержимое файлов `scheduler.{hpp,cpp}` и `fiber.{hpp,cpp}`.

Использовать библиотеку Asio нельзя.
