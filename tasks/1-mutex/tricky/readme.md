## Tricky Lock

Изучите реализацию `TrickyLock` из [tricky_lock.hpp](tricky_lock.hpp).

Реализация использует RMW (_read_-_modify_-_write_) операции [fetch_add](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add) и [fetch_sub](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub). 

Нетрудно убедиться, что `TrickyLock` гарантирует взаимное исключение.

Но помимо взаимного исключения (*safety* свойство) спинлок должен гарантировать еще и прогресс (*liveness* свойство): если несколько потоков хотят захватить свободный спинлок, то один из них непременно преуспеет в этом.

В этой задаче вам нужно построить исполнение, в котором потоки бесконечно долго не могут захватить свободный `TrickyLock`.

---

Разумеется, мы считаем, что планировщик ведет себя _честно_: если у потока остаются невыполненные инструкции, то планировщик eventually поставит его на процессор. Это требование важно для определения прогресса спинлока.

Нас не беспокоит реалистичность поведения планировщика в искомом исполнении. Мы говорим о гарантии прогресса для алгоритма взаимного исключения, и эта гарантия должна соблюдаться при _любом_ честном поведении планировщика.  

---

В файле `test.cpp` вы найдете код, в котором в цикле выполняется захват и освобождение лока. Внутри этого цикла дана развертка методов `Lock` и `Unlock`, а также критическая секция. В этом коде используются неатомарные инкременты и декременты, поскольку пример построен на кооперативных потоках, которые вы уже видели в задаче про дэдлоки.

Вы должны вставить в тело цикла переключения потоков (вызовы `Yield`) таким образом, чтобы потоки угодили в лайвлок. Разрешается вставлять только единичные вызовы `Yield`, писать новые циклы и условную логику нельзя.

Файл [tricky_lock.hpp](tricky_lock.hpp) менять не нужно, он дан лишь для ознакомления с алгоритмом.

---

Напомним семантику `Yield()` – передать управление планировщику и поместить текущий файбер (кооперативный поток) в хвост очереди на исполнение в планировщике.

---

Если вы не лишены любопытства, то подумайте, как именно тестируется эта задача. Придумать тест в данном случае – интереснее, чем придумать решение самой задачи.