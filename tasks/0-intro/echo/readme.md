# Эхо-сервер

*Programs must be written for people to read, and only incidentally for machines to execute.* - Harold Abelson, Gerald Jay Sussman

---

Эхо-сервер – это _HelloWorld_ мира сетевых приложений. Его задача – принимать
tcp-соединения клиентов, читать из них данные и отправлять их обратно. Поэтому и _эхо_.

Написать эхо-сервер можно по-разному...

## Потоки и синхронность
 
Посмотрим на простую [многопоточную реализацию](https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp) с использованием библиотеки [Asio](https://github.com/chriskohlhoff/asio/). 

В этой реализации на каждого клиента заводится отдельный поток, который в бесконечном цикле читает из клиентского сокета очередную порцию данных и затем пишет ее обратно в сокет. 

Операции чтения и записи в сокет _блокирующие_, они блокируют исполнение потока, в котором вызываются:
- Вызов `read_some` не вернет управление до тех пор, пока в сокете не появятся данные.
- Симметрично, вызов `write` не завершится, если клиент на другой стороне соединения долго не вычитывает данные. 

Это _синхронное_ API.

## Асинхронность и коллбэки
Можно написать тот же эхо-сервер совсем иначе, с использованием _асинхронного_ API, и обойтись всего одним потоком:

[Асинхронная реализация эхо-сервера](/tasks/0-intro/echo/server.hpp)

- При чтении из сокета с помощью `async_read_some` мы не блокируемся до момента появления данных, а _подписываемся_ на результат чтения – передаем в вызов _коллбэк_ (_callback_), который будет вызван после завершения чтения, после чего вызов `async_read_some` завершается _без ожидания_.
- Аналогично с записью в сокет через `async_write`. 

Мы получаем возможность в одном потоке обслуживать разные соединения.

Заметим на будущее, что коллбэки – не единственная форма асинхронного API.

## Задача

К сожалению, приведенная выше асинхронная реализация не дописана и не проходит тесты. Ваша задача – довести её до рабочего состояния.

Мы намеренно не поясняем, как работает этот код, попробуйте разобраться в нем самостоятельно.

По пути поразмышляйте над следующими вопросами:

- Зачем коллбэк, который передается в `async_read_some`, захватывает одновременно и `this`, и `self` – умный указатель на текущий `TcpConnection`, полученный из `shared_from_this()`?

- Почему в методе `AcceptClient` мы создаем _временную_ сильную ссылку на `TcpConnection` с помощью `std::make_shared`, которая разрушится в конце выражения? Разве при этом не разрушится только что созданный `TcpConnection`?

- Где в этом коде спрятан [epoll](http://man7.org/linux/man-pages/man7/epoll.7.html)?

---

Мораль этой задачи, конечно, не в том, чтобы научиться писать эхо-сервер или изучить библиотеку _Asio_, хотя и то и другое полезно само по себе. 

Эта задача должна побудить вас на размышления над тем, насколько по-разному выглядит синхронный подход с потоками и асинхронность на коллбэках, как по-разному организован в этих подходах поток управления.

Какой код, на ваш взгляд, легче читать и писать? Какая из реализаций эффективнее? К чему эти вопросы про умные указатели из предыдущего пункта? Наконец, можно ли как-то совместить сильные стороны обоих подходов?

## Материалы

* [Asio](https://github.com/chriskohlhoff/asio/)
* [Basic Asio Anatomy](http://think-async.com/Asio/asio-1.12.2/doc/asio/overview/core/basics.html)
* [Thinking Asynchronously: Designing Applications with Boost.Asio](https://www.youtube.com/watch?v=D-lTwGJRx0o), [слайды](http://cpp.mimuw.edu.pl/files/boost_vs_qt/asio/thinking_asynchronously.pdf)

## Зависимости

Для сборки этой задачи вам нужно [установить](/docs/install_asio.md) в контейнер библиотеку _Asio_.
