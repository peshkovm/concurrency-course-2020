# Взаимная блокировка

В этой задаче вам нужно воспроизвести самый известный многопоточный баг – *взаимную блокировку* или *дэдлок* (*deadlock*).

Назовем *взаимной блокировкой* такое состояние исполнения, в котором ни один из потоков не может продолжить работу независимо от дальнейшего поведения планировщика. 

Дэдлок – терминальная конфигурация, выйти из него нельзя. В этом его отличие от *лайвлока* (*livelock*), из которого всегда можно выйти при удачном планировании потоков.


## Файберы

Воспроизводить многопоточные баги сложно:
- Невозможно точно предсказать, когда планировщик операционной системы захочет снять текущий поток с процессора
- *Вытеснение* (*preemption*) происходит прозрачно для кода потока, он даже не узнает о том, что бы прерван

Чтобы преодолеть эти сложности, мы будем пользоваться специальными *кооперативными* потоками – *файберами*, с собственным планировщиком, который запускается и планирует файберы внутри одного потока операционной системы.

Главная особенность файберов – они отдают управление планировщику только явно:
- При вызове `Yield()` или `SleepFor(duration)`
- При вызове `mutex.Lock()` на захваченном [мьютексе](https://en.cppreference.com/w/cpp/thread/mutex)

Семантика вызова `Yield()` – уступить исполнение следующему в очереди на исполнение файберу. 

Планировщик не может вытеснить запущенный файбер по собственной воле. 

Используя файберы, мы можем выстраивать детерминированные конкурентные исполнения, контролируя точки переключения файберов с помощью вызовов `Yield()`, `mutex.Lock()` и `mutex.Unlock()`.

При этом суть взаимной блокировки от замены потоков на файберы не меняется.


## Задача

Ваша задача – завести файберы в дэдлок. 

Для этого заполните лямбды с комментарием
```cpp
// Your code goes here
```

Планировщик автоматически обнаружит дэдлок и бросит исключение `DeadlockDetected`.

## Блокировки и драконы

Если вам понравилось управлять планировщиком и ломать многопоточный код, то непременно поиграйте в [Deadlock Empire](https://deadlockempire.github.io/)!