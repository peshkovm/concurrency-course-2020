# Корутины

[_Корутина_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html) (_coroutine_, _сопрограмма_) – это функция, из вызова которой можно выйти в середине, а затем вернуться в него и продолжить исполнение.

Чуть аккуратнее, корутина – это объект, который представляет собой вычисление, которое может останавливаться (по собственной воле) и возобновляться (по воле вызывающего кода).

Создание корутины:
```cpp
coroutine::Coroutine co(routine);
```
Здесь `routine` – произвольная пользовательская функция.

Созданная корутина запускается вызовом `co.Resume()`. После этого управление передается функции `routine`, и она исполняется до первого вызова `Suspend()` (или до завершения функции).

Вызов `Suspend()` в корутине останавливает ее исполнение, передает управление обратно caller-у и завершает его вызов `co.Resume()`. Вызов `Suspend()` – это точка выхода из корутины, _suspension point_.

Следующий вызов `co.Resume()` вернет управление остановленной корутине, вызов `Suspend()` в ней завершится, и она продолжит исполнение до очередного `Suspend()` или же до инструкции `ret`.

Код, исполняемый внутри корутины, не имеет доступа к самому объекту `Coroutine`. Чтобы остановить исполнение, корутина вызывает standalone функцию `Suspend`.

Для лучшего понимания API и потока управления в корутинах изучите тесты к задаче, код заменит тысячу слов.  

## Терминология

Есть мнение, что говорить _корутина_ – неграмотно, что следует говорить _сопрограмма_, по аналогии с _подпрограммой_ ([subroutine](https://en.wikipedia.org/wiki/Subroutine)).

Выберите тот вариант, который вам кажется правильным.

## Виды корутин

В этой задаче мы говорим про [_stackful_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html#coroutine.intro.stackfulness) [_asymmetric_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html#coroutine.intro.execution_transfer_mechanism) корутины.

## Корутины и файберы

И корутины, и файберы описывают вычисления, которые можно остановить в специальных точках (`Suspend` и `Yield` соответственно), а позже – возобновить исполнение. Оба механизма построены на нелокальной передаче управления.

Но стоит отличать их друг от друга!  

### Файберы

Файберы – это кооперативная многозадачность: независимые вычисления исполняются конкурентно, возможно синхронизируясь друг с другом.

Потребность в файберах возникает, например, в сетевом коде: на каждый сетевой запрос создается отдельный файбер, который занимается обработкой это запроса.

За порядок исполнения файберов отвечает планировщик, он хранит очередь готовых к исполнению файберов и запускает первый из них, когда текущий файбер отдает управление.  

### Корутины

Корутины гораздо ближе к обычным функциям, чем к файберам.

Прямого отношения к конкурентности корутины не имеют. У корутин нет планировщика и очереди, управление передается от caller-а к callee и обратно через вызовы `Resume` и `Suspend`.

С исключениями корутины взаимодействуют как обычные функции: если через корутину пролетело неперехваченное исключение, то оно вылетит в caller-е из вызова `co.Resume()` и полетит дальше (выше по цепочке вызовов).

Корутины и файберы объединяет внутренняя механика: для нелокальной передачи управления они используют один и тот же механизм переключения контекста.  

Чтобы окончательно разобраться в вопросе, прочтите [Distinguishing coroutines and fibers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf).

### Файберы из корутин

В этой задаче вы должны выразить файберы через корутины.

Именно такой дизайн был выбран для реализации файберов в Java: на уровне _компилятора_ реализуются корутины, а уже поверх них на уровне _библиотеки_ реализуются файберы.
- [Project Loom with Ron Pressler and Alan Bateman](https://www.youtube.com/watch?v=J31o0ZMQEnI)
- [Project Loom: Fibers and Continuations for the Java Virtual Machine](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html)

Подумайте, в чем причины / преимущества / недостатки такого дизайна.

## Генераторы и итераторы

Есть еще один зверь, похожий на корутины – [генераторы](https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/).

Корутины / генераторы изменят ваш взгляд на реализацию итераторов: [Iteration Inside and Out](https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/)

## Задание

Вам дан класс `ExecutionContext`.

1) Реализуйте с его помощью корутины.

2) Через построенные корутины выразите файберы.

Вы можете свободно писать код в `coroutine.hpp`, `coroutine.cpp` и `fiber.cpp`.

Изменять `fiber.hpp` нельзя, он не сабмитится.

Включать заголовочные файлы из `twist/fiber` запрещается.

При работе с исключениями в корутинах используйте [std::exception_ptr](https://en.cppreference.com/w/cpp/error/exception_ptr).
