## SleepFor

Вам даны однопоточные файберы с примитивной реализацией функции `SleepFor`:

```cpp
void Scheduler::SleepFor(Duration delay) {
  Timer timer;
  do {
    Yield();
  } while (timer.Elapsed() < delay);
}
````

Как видно, файбер в вызове `SleepFor` вовсе не спит, а постоянно перепланируется, отвлекая планировщик от полезной работы.

Вы должны реализовать `SleepFor` эффективнее: спящий файбер не должен постоянно получать управление и перепланироваться, планировщик не должен тратить на него процессорное время.

Если в планировщике нет файберов, которые готовы исполняться, но при этом есть спящие файберы, то планировщик должен блокировать свой _поток_ до пробуждения первого файбера.

Обратите внимание, что никакая реализация `SleepFor` не может гарантировать, что файбер возобновит исполнение точно через заказанное время, просто в силу кооперативной природы файберов. Файбер обязан проспать не меньше `delay`, но чем точнее будет задержка, тем лучше.

---

Если посмотреть на файберы как на маленькую модель операционной системы, то от вас требуется реализовать системный вызов `sleep`.

---

Вы можете изменять содержимое файлов `scheduler.{hpp,cpp}` и `fiber.{hpp,cpp}`.

Использовать библиотеку Asio нельзя.
