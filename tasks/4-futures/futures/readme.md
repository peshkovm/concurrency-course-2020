# Futures / Promises

## Канал

В первом и очень грубом приближении _futures_ / _promises_ реализуют канал для возврата значения из асинхронной операции.

У этого канала два конца: `Promise<T>` – для записи, `Future<T>` – для чтения.

```cpp
// Где-то в программе:
// Разворачиваем канал
// `promise` отправится потоку `A` (producer), фьюча - потоку `B` (consumer)
Promise<int> promise;
auto future = promise.MakeFuture();

// Другой вариант:
// auto [future, promise] = MakeContract<int>();

// В потоке A:
// Отправляем значение, "комплитим" (от complete) фьючу
std::move(promise).SetValue(42);

// В потоке B:
// "Распаковываем" фьючу, блокируемся до появления значения / ошибки
int value = std::move(future).GetValue();
```

### Ошибки

По каналу можно передать не только значение, но и ошибку:

```cpp
// Поток A:
try { 
  //... 
} catch (...) {
  // Отправляем консьюмеру исключение
  std::move(promise).SetError(std::current_exception());
}

// Поток B:
// Синхронно дожидаемся результата и извлекаем его в виде Result<string>
auto result = std::move(future).GetResult();
if (result.IsOk()) {
    // ...
}
```

### One-Shot

Передать по каналу результат / распаковать фьючу можно _только один раз_.

Чтобы подчеркнуть это ограничение в прикладном коде, привяжем к _rvalue_ все вызовы, которые приводят к поглощению значения `Future` (и симметрично для `Promise`):

```cpp
template <typename T>
T Future<T>::GetValue() && {  // метод `GetValue` можно звать только на rvalue
    // ...
}
```

Пример:

```cpp
auto f = FetchHttp(url);
auto content = std::move(f).GetValue();
```

Теперь можно пользоваться проверкой [`bugprone-use-after-move`](https://clang.llvm.org/extra/clang-tidy/checks/bugprone-use-after-move.html) в `clang-tidy`.

### AsyncVia

С помощью фьюч легко реализовать поверх экзекуторов функциональность возврата значения / ошибки из задачи:


```cpp
auto tp = MakeStaticThreadPool(4, "tp");

auto compute = []() -> int {
    ExpectThread("tp");
    return 42;
}

// Запускаем вычислительную задачу в пуле потоков `tp` и
// блокируемся до получения результата:
std::cout << AsyncVia(compute, tp).GetValue() << std::endl;
```

### Thread-safety

Сами по себе `Future` и `Promise` – _не потокобезопасны_, каждым концом канала владеет и оперирует только один поток.

При этом образованный ими _канал_ – _потокобезопасен_, поток-продьюсер и поток-консьюмер могут конкурентно вызывать `SetValue` / `GetValue` на своем конце канала.


## Абстракция и композиция

Взгляд на `Future<T>` как на канал – слишком механический и слишком узкий.

`Future<T>` – это _абстракция_, _представление будущего результата_ асинхронной операции.

[Marius Eriksen – Your Server as a Function](https://monkey.org/~marius/funsrv.pdf)

### Источники

Типичные источники фьюч:

* Таймаут (`After`)
* Вычислительная задача в пуле потоков (`AsyncVia`)
* [Remote Procedure Call](https://capnproto.org/cxxrpc.html#promises) к внешнему сервису
* Чтение с диска

### Chaining

Чем полезна абстракция будущего результата? Зачем представлять его в виде объекта?

Будущий результат можно передать в следующую по цепочке вызовов функцию, не дожидаясь его материализации:

```cpp
// Асинхронный эквивалент ParseJson(FetchHttp(url))
// f - Future<JsonDocument>
auto f = FetchHttp(url).Then(ParseJson) 
```

Функция, переданная в `Then`, называется _продолжением_ (_continuation_). Продолжение получает единственным аргументом `Result<T>` и возвращает значение произвольного типа `U`.

Продолжение "поглощает" будущий результат, который представляет фьюча, после вызова `Then` обращаться к исходной фьюче нельзя.

Вызов `Then` – неблокирующий, он не приводит к синхронному ожиданию значения и синхронному вызову продолжения, он _планирует_ вызов продолжения после готовности фьючи.

Можно [fluently](https://en.wikipedia.org/wiki/Fluent_interface) выстраивать цепочки продолжений произвольной длины:

```cpp
std::move(f).Then(First).Then(Second).Then(Third);
```

#### Асинхронные продолжения

Продолжение может быть асинхронным, т.е. возвращать не просто `U`, а `Future<U>`. 

Этот случай требуется обработать отдельно: продолжение, следующее в цепочке за асинхронным продолжением, должно получить на вход не `Result<Future<U>>`, а `Result<U>`.

### Неблокирующие операции

В асинхронном мире блокирующие методы `GetValue` / `GetResult` практически бесполезны.

Асинхронный код – _event-driven_, каждый следующий шаг запускается по мере готовности предыдущего. Именно такое неблокирующее поведение и реализуют цепочки продолжений. 

### Комбинаторы

Возможности комбинирования фьюч не исчерпываются цепочками продолжений:

#### `All`

Собираем все результаты под одной фьючей:
```cpp
template <typename T>
Future<std::vector<T>> All(std::vector<Future<T>> futures);
```

#### `FirstOf`

Дожидаемся первого результата:
```cpp
template <typename T>
Future<T> FirstOf(std::vector<Future<T>> futures);
```

Комбинаторы составляют целый [декларативный язык](https://rufflewind.com/2017-05-15/futures-cheatsheet), на котором пользователь описывает свои конкурентные активности.

### Декоратор `WithTimeout`

Фьючи можно декорировать: 

```cpp
// Навешиваем на произвольную фьючу таймаут
auto f = WithTimeout(service.MakeRPC(input), 1s);
```

### Subscribe

Внутренняя механика продолжений и комбинаторов – _коллбэки_:

```cpp
auto f = FetchHttp(url);

std::move(f).Subscribe([](Result<std::string> content) {
  std::cout << "Content: " << content.Value() << std::endl;
}
```

Коллбэк поглощает результат фьючи, так что к фьюче можно подвесить только один коллбэк, после чего обращаться к ней больше нельзя.

## Гонка

Рассмотрим следующий пример:

```cpp
// Ранее: [f, p] = MakeContract<int>();

// В потоке A:
std::move(p).SetValue(42);

// В то же время в потоке B:
std::move(f).Then(ProcessValue);
```

Вызовы `Then` и `SetValue` гоняются друг с другом, неизвестно, что случится раньше – установка коллбэка или значения. А от этого в свою очередь зависит в каком потоке будет вызван коллбэк.

Эта неопределенность может привести к неприятным последствиям:

Пусть библиотека _L_ реализует некоторую асинхронную функцию. Пользователь вызвал эту функцию, получил фьючу и подвесил к ней тяжелое вычисление, после чего про фьючу забыл. Когда библиотека _L_ будет комплитить фьючу, то ей придется запустить в собственном внутреннем потоке пользовательский коллбэк с тяжелым вычислением.

### Экзекуторы

Пользователь, планирующий с помощью фьюч цепочку асинхронных действий, должен иметь контроль на тем, в каких потоках эти действия будут выполняться. И здесь ему на помощью приходят _экзекуторы_.

Продолжение (или произвольный коллбэк) можно запланировать на запуск в конкретном экзекуторе с помощью метода `Via`:

```cpp
// Пул потоков для запуска вычислительных задач
auto cpu_tp = MakeStaticThreadPool(4, "cpu");

// Запускаем распаковку чанка в пуле потоков `cpu_tp`
auto f = FetchChunk(chunk_id).Via(cpu_tp).Then(DecompressChunk);
```

Установленный через `Via` экзекутор передается вперед по всей цепочке продолжений:
```cpp
// Вызовы `a` -> `b` -> `c` будут исполняться экзекутором `e1`
// Последний вызов в цепочке будет выполнен в экзекуторе `e2`
std::move(f).Via(e1).Then(a).Then(b).Then(c).Via(e2).Then(d);
```

## SemiFuture / ContinuableFuture

API фьюч можно усовершенствовать: статически запретить "передавать" фьючу в следующей по цепочке вызов без явного указания экзекутора.

В [Folly/Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md) фьюча может принимать две формы:

* `Future<T>` – фьюча, которая уже ассоциирована с экзекутором, ее можно связать с продолжением
* `SemiFuture<T>` – фьюча, с которой можно работать только синхронно _либо_ трансформировать ее в `Future<T>` с помощью `Via`

[Future vs. SemiFuture](https://github.com/facebook/folly/blob/e270048526d5c65f6dcba13c6e1d5045398847de/folly/futures/Future.h#L466)

```cpp
// Неполноценная фьюча
auto semi_future = FetchHttp(url);

// Можно:
// auto data = std::move(semi_future).Get();
// Нельзя:
// std::move(semi_future).Then(ParseJson);

// Трансформируем в полноценную фьючу с помощью `Via` и строим пайплайн
auto std::move(semi_future).Via(e).Then(ParseJson).Then(ProcessJson);
```

Публичные API должны возвращать своим клиентам только `SemiFuture<T>`.

## Future / Promise

Может показаться, что разделение на две сущности `Promise` и `Future` не обязательное и избыточное.

На практике разработчик прикладного асинхронного кода работает лишь с read-only фьючами и комбинаторами. Все возникающие по пути промисы и `Set`-ы - это изнанка фьюч, они спрятаны в реализации комбинаторов и асинхронных сервисов, генерирующих фьючи.

## Фьючи и корутины в С++

Фьючи интегрируются с корутинами:
1) Их можно ждать с помощью `co_await`
2) Их можно использовать для комбинирования корутинных и не-корутинных вызовов

[CppCon 2017: Gor Nishanov “Naked coroutines live (with networking)”](https://www.youtube.com/watch?v=UL3TtTgt3oU)

## Декларативность / среда исполнения

С помощью комбинаторов пользователь _декларативно_ описывает графы своих конкурентных активностей, а _экзекуторы_ исполняют их на ограниченном наборе потоков.

## Проблемы абстракции

* Вместо программирования на языке программирования пользователь вынужден программировать на языке комбинаторов. Декларативность этого языка становится препятствием для выражения простых императивных конструкций: циклов и ветвлений.

* Фьючи не дают удобных инструментов для отмены асинхронных операций, поскольку нужно отправить сигнал в неестественном для фьюч направлении: от консьюмеров к продьюсерам.

* Сама абстракция `Future`/`Promise` содержит гонку между продьюсером и консьюмером, что требует аллокации на куче, атомарного подсчета ссылок и синхронизации.

## References

- [Your Server as a Function](https://monkey.org/~marius/funsrv.pdf), [Finagle – Concurrent Programming with Futures](https://twitter.github.io/finagle/guide/Futures.html)
- [Futures for C++11 at Facebook](https://engineering.fb.com/developer-tools/futures-for-c-11-at-facebook/), [Folly Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md), 
- [Zero-cost futures in Rust](http://aturon.github.io/blog/2016/08/11/futures/), [Designing futures for Rust](http://aturon.github.io/blog/2016/09/07/futures-design/)


## Задание

1) Реализуйте блокирующую функциональность фьюч: вариации `Set`-ов и `Get`-ов
2) Реализуйте `AsyncVia`
3) Реализуйте метод `Subscribe`
4) Реализуйте комбинаторы `All` и `FirstOf`
5) Реализуйте декоратор `WithTimeout`
6) Реализуйте продолжения: две перегрузки `Then` для синхронных и асинхронных продолжений

## Заметки по реализации

Вместо специализации для `void` предлагается с чуть меньшим комфортом работать с `Future<Unit>`.

Используйте `support::UniqueFunction`, которая умеет оборачивать move-only лямбды.

В реализации будет много служебных лямбд-замыканий, которые захватывают `Promise`-ы. Маркируйте такие лямбды как `mutable`.

Перемещайте, а не копируйте `Result<T>` в шаблонном коде.

Если вам нужно вызвать функцию и завернуть ее результат / исключение в `Result`, то используйте `support::make_result::Invoke`.

## `std::`


- `std::function` не поддерживает move-only лямбды, из которых состоит реализация фьюч
- `std::future` не поддерживает продолжения / коллбэки