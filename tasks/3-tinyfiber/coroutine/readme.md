# Корутины

[_Корутина_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html) (или _сопрограмма_, _coroutine_) – это функция, из вызова которой можно выйти в середине, а затем вернуться в него и продолжить исполнение.

Чуть аккуратнее, корутина – это объект, который представляет собой вычисление, которое может останавливаться (по собственной воле) и возобновляться (по воле вызывающего кода).

Создание корутины:
```cpp
coroutine::Coroutine co(routine);
```
Здесь `routine` – произвольная пользовательская функция.

Созданная корутина запускается вызовом `co.Resume()`. После этого управление передается функции `routine`, и та исполняется до первого вызова `Suspend()` (или до своего завершения).

Вызов `Suspend()` в корутине останавливает ее исполнение, передает управление обратно caller-у и завершает его вызов `co.Resume()`. Вызов `Suspend()` – это точка выхода из корутины, _suspension point_.

Следующий вызов `co.Resume()` вернет управление остановленной корутине, вызов `Suspend()` в ней завершится, и она продолжит исполнение до очередного `Suspend()` или же до инструкции `ret`.

Код, исполняемый внутри корутины, не имеет доступа к самому объекту `Coroutine`. Чтобы остановить исполнение, корутина вызывает standalone функцию `Suspend`.

Для лучшего понимания API и потока управления в корутинах изучите тесты к задаче, код заменит тысячу слов.  

## Терминология

Есть мнение, что говорить _корутина_ – неграмотно и вульгарно, вместо этого следует употреблять термин _сопрограмма_, по аналогии с _подпрограммой_ ([subroutine](https://en.wikipedia.org/wiki/Subroutine)).

Выберите вариант по душе.

## Виды корутин

В этой задаче мы говорим про [_stackful_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html#coroutine.intro.stackfulness) [_asymmetric_](https://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/coroutine/intro.html#coroutine.intro.execution_transfer_mechanism) корутины.

## Корутины и файберы

И корутины, и файберы описывают вычисления, которые можно остановить (с помощью `Suspend` и `Yield` соответственно), а затем – возобновить. Оба механизма построены на нелокальной передаче управления.

Но стоит отличать их друг от друга!  

### Файберы

Файберы – это кооперативная многозадачность: независимые вычисления исполняются конкурентно, возможно синхронизируясь друг с другом.

За порядок исполнения файберов отвечает планировщик, он хранит очередь готовых к исполнению файберов и запускает первый из них, когда текущий файбер отдает управление.  

### Корутины

Корутины гораздо ближе к обычным функциям, чем к файберам.

Прямого отношения к конкурентности корутины не имеют. У корутин нет планировщика и очереди, управление передается от caller-а к callee и обратно через вызовы `Resume` и `Suspend`.

С исключениями корутины взаимодействуют как обычные функции: если через корутину пролетело неперехваченное исключение, то оно вылетит в caller-е из вызова `co.Resume()` и полетит дальше (выше по цепочке вызовов).

Корутины и файберы объединяет внутренняя механика: для нелокальной передачи управления они используют один и тот же механизм переключения контекста.  

Чтобы окончательно разобраться в вопросе, прочтите [Distinguishing coroutines and fibers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf).

## Файберы из корутин

В этой задаче вы должны выразить файберы через корутины.

Вам _уже_ дан готовый многопоточный планировщик – _пул потоков_ (_thread pool_), написанный с помощью библиотеки _Asio_.

## Пул потоков

Пул потоков ничего не знает про корутины, он исполняет абстрактные _задачи_ – `std::function<void()>`.

Пример использования:
```cpp
// Создаем пул из 4-х потоков
ThreadPool thread_pool{/*threads=*/4};

auto hello = []() {
  std::cout << "Hello from pool!" << std::endl;
};

// Задача будет запущена в одном из 4-х потоков пула
// Вызов `Submit` вернет управление без ожидания
thread_pool.Submit(hello); 
```

Задачу в пул можно добавить не только снаружи, но и прямо из исполняемой задачи:

```cpp
auto deeper = []() {
  // Находим текущий пул и кладем в него задачу
  ThreadPool::Current()->Submit(
    []() {
      std::cout << "We need to go depeer" << std::endl;
    }
  )
};

// Бросаем в пул внешнюю задачу
thread_pool.Submit(deeper); 
```

Для остановки пула потоков нужно вызвать метод `Shutdown`. После этого вызова потоки-воркеры внутри пула будут работать до тех пор, пока его очередь задач не опустеет.

### Корутины и асинхронность

Корутины – базовый механизм, с помощью которого асинхронность реализуется в современных языках программирования:

### C++

- [Гор Нишанов, C++ Coroutines – a negative overhead abstraction](https://www.youtube.com/watch?v=Ts-1mWBmTNE)
- https://github.com/lewissbaker/cppcoro

### Java

На уровне _компилятора_ реализуются корутины, а уже поверх них на уровне _библиотеки_ реализуются файберы.
- [Project Loom with Ron Pressler and Alan Bateman](https://www.youtube.com/watch?v=J31o0ZMQEnI)
- [Project Loom: Fibers and Continuations for the Java Virtual Machine](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html)

### Kotlin
- [Kotlin Coroutines Proposal](https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md)
- [KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov](https://www.youtube.com/watch?v=_hfBv0a09Jc)

## Генераторы и итераторы

Есть еще один зверь, похожий на корутины – [генераторы](https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/).

Корутины / генераторы изменят ваш взгляд на реализацию итераторов: [Iteration Inside and Out](https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/)

## Задание

1) С помощью `ExecutionContext` реализуйте корутины.

2) Через построенные корутины выразите файберы.

Вы можете писать код в `coroutine.hpp`, `coroutine.cpp` и `fiber.cpp`.

Включать заголовочные файлы из `twist/fiber` запрещается.

При работе с исключениями в корутинах используйте [std::exception_ptr](https://en.cppreference.com/w/cpp/error/exception_ptr).
