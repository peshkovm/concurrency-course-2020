## SleepFor

Вам даны однопоточные файберы с примитивной реализацией функции `SleepFor`:

```cpp
void Scheduler::SleepFor(Duration delay) {
  Timer timer;
  do {
    Yield();
  } while (timer.Elapsed() < delay);
}
````

Как видно, файбер в вызове `SleepFor` вовсе не спит, а постоянно перепланируется, отвлекая планировщик от полезной работы.

Вы должны реализовать `SleepFor` эффективнее, через блокировку файбера.

Файбер, спящий в `SleepFor`, не должен постоянно получать управление и перепланироваться, планировщик не должен тратить на него процессорное время.

Если в планировщике нет файберов, которые готовы исполняться, но при этом есть спящие файберы, то планировщик должен блокировать свой поток до пробуждения первого файбера и не жечь процессорное время.

Обратите внимание, что никакая реализация `SleepFor` не может гарантировать, что файбер возобновит исполнение точно через заказанное время, просто в силу кооперативной природы файберов. Файбер обязан проспать не меньше `delay`, но чем точнее будет задержка, тем лучше.

---

Если посмотреть на файберы как на упрощенную модель операционной системы, то можно догадаться, что вас просят реализовать системный вызов `sleep`.

---

В этой задаче вы можете изменять содержимое файлов `scheduler.{hpp,cpp}` и `fiber.{hpp,cpp}`.

