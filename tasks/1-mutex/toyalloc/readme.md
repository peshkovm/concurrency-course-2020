# Аллокатор

В этой задаче вам нужно написать игрушечный потокобезопасный аллокатор.

Аллокатор будет аллоцировать блоки *фиксированного* размера, аллокация выполняется функцией `Allocate`.

Арена памяти, из которой аллокатор будет черпать блоки, задается снаружи через функцию `Init`.

Если аллокатор исчерпал отведенную ему арену, то вызов `Allocate` должен возвращать `nullptr`.

Разумеется, реальный аллокатор будет сам аллоцировать память у операционной системы, не будет ограничиваться одной ареной, будет аллоцировать блоки произвольного размера.
 
Все ограничения и условности задачи нужны для того, чтобы упростить тестирование и реализацию, избавиться от несущественных с точки зрения задачи деталей.  

## Реализация

Аллокатор должен повторно выделять блоки, которые были возвращены ему через `Free`. Для этого он должен хранить свободные блоки в односвязном списке.

Аллокатор не должен выделять дополнительную память на куче. Разрешается использовать _только_ данную в `Init` арену памяти. Запрещется использовать функцию `malloc` и оператор `new`, также нельзя использовать стандартные контейнеры, которые размещают на куче свои узлы / буферы / чанки.

Менять API аллокатора в заголовочном файле `toyalloc.hpp` нельзя.

Можно считать, что аллокатором пользуются правильно:
- В вызовы `Free` передают только те адреса, которые ранее отдал `Allocate`
- Не освобождают дважды один и тот же выделенный блок
- Не пишут в память за границами выделенных блоков

## Thread-safety

Аллокатор должен быть *потокобезопасным* (*thread-safe*): выделять и освобождать блоки памяти будут из разных потоков.

## Fork

http://man7.org/linux/man-pages/man2/fork.2.html

Системный вызов `fork` создает копию текущего процесса – *дочерний* процесс. Процесс, вызвавший `fork`, называется *родительским*. 

Дочерний процесс получает копию всей памяти родительского процесса. Память копируется не прямо во время вызова `fork`, а лениво, с помощью механизма [copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write#In_virtual_memory_management).

Память дочернего процесса *изолирована* от памяти родительского: запись, сделанная в родительском процессе, не будет видна в дочернем, и наоборот.

Вызов `fork` появился задолго до появления потоков и до сих пор ничего о них не знает! Независимо от того, сколько потоков бежало в родительском процессе в момент вызова `fork`, в дочернем процессе будет только один поток – тот, который вызвал `fork` в родителе, остальные потоки будут потеряны. В родительском процессе потоки не пострадают.

## Fork-safety

Аллокатор должен быть *fork-safe*: после вызова `fork` он должен продолжить корректно обслуживать аллокации как в родительском, так и в дочернем процессе, несмотря на потерю потоков в последнем.

## Задание

- Реализуйте потокобезопасный аллокатор.
- Подумайте, как потеря потоков при вызове `fork` может привести к известному вам многопоточному багу внутри аллокатора в дочернем процессе.
- Придумайте, как избежать проблемы из предыдущего пункта. Решать эту проблему приходится любому современному аллокатору.

Для решения вам пригодится функция из библиотеки pthreads: http://man7.org/linux/man-pages/man7/pthreads.7.html

## Реальность

Разумеется, настоящие аллокаторы устроены намного сложнее:

1) Они умеют аллоцировать блоки произвольного размера.
2) Не хранят внутри один список блоков, защищенный одной толстой блокировкой, а используют более сложную организацию данных, что позволяет аллокациям блокировать только часть внутреннего состояния аллокатора и за счет этого выполняться параллельно.
3) Часто вообще не требуют брать блокировку при аллокации за счет использования локального для потока кэша свободных блоков.

Пример современного производительного аллокатора – [jemalloc](https://github.com/jemalloc/jemalloc)

### A fork in the road

Существует мнение, что `fork`, который изначально задумывался как ловкий трюк, сейчас приносит больше неудобств, чем пользы: [A `fork`()` in the road](https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf).
